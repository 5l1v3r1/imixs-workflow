            ------
            Performance
            ------
            Ralph Soika - Imixs Software Solutions GmbH
            ------
 
 






Performance
~~~~~~~~~~~~~~

 In large databases with a lot of workitems there can occur a performance issue which 
 slows down the response time of an application in some situations.
 The reason for this issue is the default database schema. This schema is generated by the application server the
 first time the Imixs Workflow engine where deployed. 
 
 This is a typical example with more than one JOIN clauses that can result in a slow-down of the response time :

+----------------------------------------+
SELECT DISTINCT environment FROM Entity AS environment
 JOIN environment.textItems as n 
 JOIN environment.textItems as v
 JOIN environment.textItems as c
 AND environment.type = 'WorkflowEnvironmentEntity'
 AND n.itemName = 'txtname' AND n.itemValue = 'environment.profile'
 AND v.itemName = '$modelversion' AND v.itemValue = 'public-de-standard-0.0.1'
 AND c.itemName = 'case'
 ORDER BY c.itemValue 
+----------------------------------------+

 To fix this problem it is necessary to add additional indices to the database tables generated by the 
 application servers OR-Mapper. This can be done with the database tools provided by your database
 vendor. For MySQL use the "MySQL Administrator Tool"
 
 The most important tables where an additional index should be added are the database tables
 "ENTITY", "TEXTITEM", "INTEGERITEM" and "CALENDARITEM".
 This tables typical holds the most data rows. Useful default indices to the columns "TYPE", "ITEMVALUE" and "ITEMNAME"
 are not created per default. 
 So to add the necessary index manually you run call the following SQL commands: 
 
+----------------------------------------+
ALTER TABLE `ENTITY` ADD INDEX `index1`(`CREATED`,`MODIFIED`,`TYPE`,`VERSION`);
ALTER TABLE `TEXTITEM` ADD INDEX `index1`(`ITEMNAME`, `ITEMVALUE`);
ALTER TABLE `INTEGERITEM` ADD INDEX `index1`(`ITEMNAME`, `ITEMVALUE`);
ALTER TABLE `CALENDARITEM` ADD INDEX `index1`(`ITEMNAME`, `ITEMVALUE`);
ALTER TABLE `DOUBLEITEM` ADD INDEX `index1`(`ITEMNAME`, `ITEMVALUE`);
ALTER TABLE `READACCESS` ADD INDEX `index1`(`VALUE`);
ALTER TABLE `WRITEACCESS` ADD INDEX `index1`(`VALUE`);
+----------------------------------------+

 After adding the index the response time should be nice again.
 
  [Note:] It can be necessary to add also indices to other tables/columns created by the OR-Mapper. To find 
         out useful indices contact your database administrator or use Query analyser tools provided
         by your database vendor.
         
         
Foreign key constraint failures  
~~~~~~~~~~~~~~

 In some situations a SQL Exception forced by a foreign key constraint failure can occur
 during complex transactions. In this case the wrong a cascading type of the auto generated
 foreign keys can be the reason. 
 Use the following sql statements to alter the foreign key from 'ON DELETE RESTRICT' to 
 'ON DELETE CASCADE' to fix the problem. Make sure that you stop GlassFish before changing the keys.
 
*MySQL
~~~~~~~~~~~~~~
 
+----------------------------------------+
ALTER TABLE `ENTITY_WRITEACCESS` 
DROP FOREIGN KEY `FK_ENTITY_WRITEACCESS_writeAccessList_ID`;
ALTER TABLE `ENTITY_WRITEACCESS` 
ADD CONSTRAINT `FK_ENTITY_WRITEACCESS_writeAccessList_ID`
  FOREIGN KEY (`writeAccessList_ID`)
  REFERENCES `WRITEACCESS` (`ID`)
  ON DELETE CASCADE
  ON UPDATE RESTRICT;
  
ALTER TABLE `ENTITY_READACCESS` 
DROP FOREIGN KEY `FK_ENTITY_READACCESS_readAccessList_ID`;
ALTER TABLE `ENTITY_READACCESS` 
ADD CONSTRAINT `FK_ENTITY_READACCESS_readAccessList_ID`
  FOREIGN KEY (`readAccessList_ID`)
  REFERENCES `READACCESS` (`ID`)
  ON DELETE CASCADE
  ON UPDATE RESTRICT;

ALTER TABLE `ENTITY_TEXTITEM` 
DROP FOREIGN KEY `FK_ENTITY_TEXTITEM_textItems_ID`;
ALTER TABLE `ENTITY_TEXTITEM` 
ADD CONSTRAINT `FK_ENTITY_TEXTITEM_textItems_ID`
  FOREIGN KEY (`textItems_ID`)
  REFERENCES `TEXTITEM` (`ID`)
  ON DELETE CASCADE
  ON UPDATE RESTRICT; 
  
ALTER TABLE `ENTITY_INTEGERITEM` 
DROP FOREIGN KEY `FK_ENTITY_INTEGERITEM_integerItems_ID`;
ALTER TABLE `ENTITY_INTEGERITEM` 
ADD CONSTRAINT `FK_ENTITY_INTEGERITEM_integerItems_ID`
  FOREIGN KEY (`integerItems_ID`)
  REFERENCES `INTEGERITEM` (`ID`)
  ON DELETE CASCADE
  ON UPDATE RESTRICT; 
  
ALTER TABLE `ENTITY_DOUBLEITEM` 
DROP FOREIGN KEY `FK_ENTITY_DOUBLEITEM_doubleItems_ID`;
ALTER TABLE `ENTITY_DOUBLEITEM` 
ADD CONSTRAINT `FK_ENTITY_DOUBLEITEM_doubleItems_ID`
  FOREIGN KEY (`doubleItems_ID`)
  REFERENCES `DOUBLEITEM` (`ID`)
  ON DELETE CASCADE
  ON UPDATE RESTRICT; 
  
ALTER TABLE `ENTITY_CALENDARITEM` 
DROP FOREIGN KEY `FK_ENTITY_CALENDARITEM_calendarItems_ID`;
ALTER TABLE `ENTITY_CALENDARITEM` 
ADD CONSTRAINT `FK_ENTITY_CALENDARITEM_calendarItems_ID`
  FOREIGN KEY (`calendarItems_ID`)
  REFERENCES `CALENDARITEM` (`ID`)
  ON DELETE CASCADE
  ON UPDATE RESTRICT; 
+----------------------------------------+

*PostgreSQL
~~~~~~~~~~~~~~
 
+----------------------------------------+
ALTER TABLE ENTITY_TEXTITEM
DROP constraint FK_ENTITY_TEXTITEM_textItems_ID,
ADD CONSTRAINT FK_ENTITY_TEXTITEM_textItems_ID
  FOREIGN KEY (textItems_ID)
  REFERENCES TEXTITEM (ID)
  ON DELETE CASCADE; 

ALTER TABLE ENTITY_INTEGERITEM
DROP constraint FK_ENTITY_INTEGERITEM_integerItems_ID,
ADD CONSTRAINT FK_ENTITY_INTEGERITEM_integerItems_ID
  FOREIGN KEY (integerItems_ID)
  REFERENCES INTEGERITEM (ID)
  ON DELETE CASCADE;

ALTER TABLE ENTITY_DOUBLEITEM
DROP constraint FK_ENTITY_DOUBLEITEM_doubleItems_ID,
ADD CONSTRAINT FK_ENTITY_DOUBLEITEM_doubleItems_ID
  FOREIGN KEY (doubleItems_ID)
  REFERENCES DOUBLEITEM (ID)
  ON DELETE CASCADE;

ALTER TABLE ENTITY_CALENDARITEM
DROP constraint FK_ENTITY_CALENDARITEM_calendarItems_ID,
ADD CONSTRAINT FK_ENTITY_CALENDARITEM_calendarItems_ID
  FOREIGN KEY (calendarItems_ID)
  REFERENCES CALENDARITEM (ID)
  ON DELETE CASCADE;

ALTER TABLE ENTITY_WRITEACCESS
DROP constraint FK_ENTITY_WRITEACCESS_writeAccessList_ID,
ADD CONSTRAINT FK_ENTITY_WRITEACCESS_writeAccessList_ID
  FOREIGN KEY (writeAccessList_ID)
  REFERENCES WRITEACCESS (ID)
  ON DELETE CASCADE;

ALTER TABLE ENTITY_READACCESS
DROP constraint FK_ENTITY_READACCESS_readAccessList_ID,
ADD CONSTRAINT FK_ENTITY_READACCESS_readAccessList_ID
  FOREIGN KEY (readAccessList_ID)
  REFERENCES READACCESS (ID)
  ON DELETE CASCADE;
+----------------------------------------+